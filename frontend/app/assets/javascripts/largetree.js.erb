//= require jquery.ba-hashchange

//= require tree_ids_helpers
//= require ajaxtree
//= require tree_renderers
//= require tree_toolbar

(function (exports) {
    "use strict";

    var SCROLL_DELAY_MS = 25;
    var THRESHOLD_EMS = 300;

    function LargeTree(datasource, container, root_uri, read_only, renderer, tree_loaded_callback, node_selected_callback) {
        this.source = datasource;
        this.elt = container;
        this.scrollTimer = undefined;
        this.renderer = renderer;

        this.root_uri = root_uri;
        this.root_tree_id = TreeIds.uri_to_tree_id(root_uri);
        this.read_only = read_only;

        // default to the root_id
        this.current_tree_id = this.root_tree_id;

        this.waypoints = {};

        this.node_selected_callback = node_selected_callback;

        this.initEventHandlers();
        this.renderRoot(function () {
            tree_loaded_callback();
        });
    }

    LargeTree.prototype.displayNode = function (tree_id) {
        var self = this;

        var bits = tree_id.split("_")

        var node_id = TreeIds.parse_tree_id(tree_id).id;

        self.source.fetchPathFromRoot(node_id).done(function (path) {
            self.recursivelyExpandWaypoints(path, function () {
                var current = $('#' + tree_id);
                current.find('a.record-title')[0].focus();

                $.proxy(self.node_selected_callback, self)(current, tree);
            });
        });
    }

    LargeTree.prototype.recursivelyExpandWaypoints = function (path, done_callback) {
        var self = this;

        /*
           Here, `path` is a list of objects like:

             node: /some/uri; offset: NN

           which means "expand subtree /some/uri then expand waypoint NN".

           The top-level is special because we automatically show it as expanded, so we skip expanding the root node.
         */

        if (path.length == 0) {
            done_callback();
            return;
        }

        var waypoint_description = path.shift();

        var next_fn = function () {
            var waypoint = self.waypoints[waypoint_description.node][waypoint_description.offset];

            self.expandWaypoint(waypoint, function () {
                self.recursivelyExpandWaypoints(path, done_callback);
            })
        };

        if (waypoint_description.node) {
            var tree_id = TreeIds.uri_to_tree_id(waypoint_description.node)

            self.openNode($('#' + tree_id).find('.expandme'), next_fn);
        } else {
            /* this is the root node (subtree already expanded) */
            next_fn();
        }
    };

    LargeTree.prototype.deleteWaypoints = function (parent) {
        var waypoint = parent.next();

        if (!waypoint.hasClass('waypoint')) {
            /* Nothing left to burn */
            return false;
        }

        if (waypoint.hasClass('collapsed')) {
            waypoint.remove();

            return true;
        }

        var waypointLevel = waypoint.data('level');

        if (!waypointLevel) {
            return false;
        }

        /* Delete all elements up to and including the end waypoint marker */
        while (true) {
            var elt = waypoint.next();

            if (elt.length == 0) {
                break;
            }

            if (elt.hasClass('end-marker') && waypointLevel == elt.data('level')) {
                elt.remove();
                break;
            } else {
                elt.remove();
            }
        }

        waypoint.remove();

        return true;
    }

    LargeTree.prototype.openNode = function (button, done_callback) {
        var self = this;
        var parent = button.closest('tr');

        if (button.data('expanded')) {
            /* Collapse it */
            while (self.deleteWaypoints(parent)) {
                /* Remove the elements from one or more waypoints */
            }

            $(button).data('expanded', false);
            $('.expandme-icon', button).removeClass('expanded');
        } else {
            /* Expand it */
            $('.expandme-icon', button).addClass('expanded');
            $(button).data('expanded', true);

            self.source.fetchNode(parent.data('uri')).done(function (node) {
                self.appendWaypoints(parent, parent.data('uri'), node.waypoints, node.waypoint_size, parent.data('level') + 1);
                if (done_callback) {
                    done_callback();
                }
            });
        }
    };

    LargeTree.prototype.initEventHandlers = function () {
        var self = this;
        var currentlyExpanding = false

        /* Content loading */
        this.elt.on('scroll', function (event) {
            if (self.scrollTimer) {
                clearTimeout(self.scrollTimer);
            }

            self.scrollTimer = setTimeout(function () {
                if (!currentlyExpanding) {
                    currentlyExpanding = true;

                    self.considerExpandingWaypoint(function () {
                        currentlyExpanding = false;
                    });
                }
            }, SCROLL_DELAY_MS);
        });

        /* Expand/collapse nodes */
        $(this.elt).on('click', '.expandme', function (e) {
            e.preventDefault();
            self.openNode($(this));
        });


        /* Drag and drop! */
        (function () {
            var DRAG_DELAY = 100;
            var MOUSE_OFFSET = 20;
            var EXPAND_DELAY = 200;
            var HOTSPOT_HEIGHT = 200;
            var AUTO_SCROLL_SPEED = 200;

            var dragActive = false;
            var dragIndicator = $('<div class="tree-drag-indicator" />');
            var rowsToMove = [];

            var scrollUpHotspot = $('<div class="tree-scroll-hotspot tree-scroll-up-hotspot" />');
            var scrollDownHotspot = $('<div class="tree-scroll-hotspot tree-scroll-down-hotspot" />');

            var dragDelayTimer = undefined;
            var expandTimer = undefined;
            var autoScrollTimer = undefined;

            var lastCursorPosition = undefined;

            /* Drag/drop */
            $(self.elt).on('mousedown', '.drag-handle', function (event) {
                var selection = $(this);
                if (event.ctrlKey) {
                    $(this).addClass('multiselected');

                    return false;
                }

                dragDelayTimer = setTimeout(function () {
                    if ($('.multiselected', self.elt).length > 0) {
                        rowsToMove = $('.multiselected', self.elt).closest('tr').toArray();
                    } else {
                        rowsToMove = [selection.closest('tr')[0]];
                    }

                    dragActive = true;

                    scrollUpHotspot.width(self.elt.width()).height(HOTSPOT_HEIGHT);
                    scrollDownHotspot.width(self.elt.width()).height(HOTSPOT_HEIGHT);

                    scrollUpHotspot.css('top', self.elt.offset().top - HOTSPOT_HEIGHT)
                                   .css('left', self.elt.offset().left);
                    scrollDownHotspot.css('top', self.elt.offset().top + self.elt.height())
                                     .css('left', self.elt.offset().left);

                    dragIndicator.empty().hide();
                    dragIndicator.append($('<ul />').append(rowsToMove.map(function (elt, idx) {
                        return $('<li />').text($(elt).find('.title').text());
                    })));


                    $(self.elt).focus();

                    $('body').prepend(dragIndicator);
                    $('body').prepend(scrollUpHotspot);
                    $('body').prepend(scrollDownHotspot);
                }, DRAG_DELAY);

                return false;
            });

            $(document).on('click', function (event) {
                if (!event.ctrlKey && !$(event.target).hasClass('drag-handle')) {
                    $(self.elt).find('.multiselected').removeClass('multiselected');
                }
            });

            $(document).on('mousemove', function (event) {
                if (dragActive) {
                    lastCursorPosition = {x: event.clientX, y: event.clientY};

                    dragIndicator[0].style.left = (event.clientX + MOUSE_OFFSET) + 'px';
                    dragIndicator[0].style.top = (event.clientY + MOUSE_OFFSET) + 'px';
                    dragIndicator[0].style.display = 'inline-block';
                }
            });

            $(self.elt).on('mouseout', '.expandme', function (event) {
                if (expandTimer) {
                    clearTimeout(expandTimer);
                    expandTimer = undefined;
                }
            });

            $(self.elt).on('mouseover', '.expandme', function (event) {
                var button = $(this);

                if (dragActive && button.find('.expanded').length == 0) {
                    expandTimer = setTimeout(function () {
                        self.openNode(button);
                    }, EXPAND_DELAY);
                }
            });

            $(self.elt).on('mouseenter', 'tr.largetree-node', function (event) {
                if (dragActive) {
                    $(this).addClass('drag-drop-over');
                }
            });

            $(self.elt).on('mouseleave', 'tr.largetree-node', function (event) {
                if (dragActive) {
                    $(this).removeClass('drag-drop-over');
                }
            });

            $(document).on('mouseenter', '.tree-scroll-hotspot', function (event) {
                var hotspot = event.target;

                var direction = 1;

                if ($(hotspot).hasClass('tree-scroll-up-hotspot')) {
                    direction = -1;
                }

                var hotspotBounds = hotspot.getBoundingClientRect();
                autoScrollTimer = setInterval(function () {
                    if (lastCursorPosition) {
                        var scrollAcceleration = (lastCursorPosition.y - hotspotBounds.top) / hotspotBounds.height;

                        if (direction == -1) {
                            scrollAcceleration = (1 - scrollAcceleration);
                        }

                        var position = $(self.elt).scrollTop();

                        $(self.elt).scrollTop(position + (direction * AUTO_SCROLL_SPEED * scrollAcceleration));
                    }
                }, 50);
            });

            $(document).on('mouseout', '.tree-scroll-hotspot', function (event) {
                if (autoScrollTimer) {
                    clearTimeout(autoScrollTimer);
                }
                autoScrollTimer = undefined;
            });


            $(document).on('mouseup', function (event) {
                if (dragActive) {
                    dragActive = false;
                    dragIndicator.remove();
                    $(self.elt).find('.drag-drop-over').removeClass('drag-drop-over');
                    $(self.elt).find('.multiselected').removeClass('multiselected');

                    if (autoScrollTimer) {
                        console.log("Cancelling timer");
                        clearTimeout(autoScrollTimer);
                        autoScrollTimer = undefined;
                    }

                    $(document).find('.tree-scroll-hotspot').remove();

                    console.log("Do something with", rowsToMove);

                    event.preventDefault();
                    return false;
                }

                if (dragDelayTimer) {
                    clearTimeout(dragDelayTimer);
                    dragDelayTimer = undefined;
                }

                return true;
            });
        }());
    };

    LargeTree.prototype.makeWaypoint = function (uri, offset, indentLevel) {
        var result = $('<tr class="waypoint collapsed" />');
        result.addClass('indent-level-' + indentLevel);

        result.data('level', indentLevel);
        result.data('uri', uri);
        result.data('offset', offset);

        if (!this.waypoints[uri]) {
            this.waypoints[uri] = {}
        }

        /* Keep a lookup table of waypoints so we can find and expand them programmatically */
        this.waypoints[uri][offset] = result;

        return result;
    };

    LargeTree.prototype.appendWaypoints = function (elt, parentURI, waypointCount, waypointSize, indentLevel) {
        for (var i = waypointCount - 1; i >= 0; i--) {
            var waypoint = this.makeWaypoint(parentURI, i, indentLevel);

            /* We force the line height to a constant 2em so we can predictably
               guess how tall to make waypoints.  See largetree.less for where we
               set this on table.td elements. */
            waypoint.css('height', (waypointSize * 2) + 'em');
            elt.after(waypoint);
        }

        var self = this;
        setTimeout(function () {self.considerExpandingWaypoint(); }, 0);
    };

    LargeTree.prototype.renderRoot = function (completed_callback) {
        var self = this;
        var rootList = $('<table class="root" />');

        this.source.fetchRootNode().done(function (rootNode) {
            var row = self.renderer.get_root_template();

            row.data('uri', rootNode.uri);
            row.attr('id', TreeIds.uri_to_tree_id(rootNode.uri));
            row.addClass('root-row');
            row.data('indent', 0);
            row.data('jsonmodel_type', rootNode.jsonmodel_type);
            row.find('.title').append($('<a>').attr('href', TreeIds.link_url(rootNode.uri))
                                              .text(rootNode.title));

            rootList.append(row);
            self.appendWaypoints(row, null, rootNode.waypoints, rootNode.waypoint_size, 1);

            self.elt.append(rootList);
            self.renderer.add_root_columns(row, rootNode);
            completed_callback();
        });
    };

    LargeTree.prototype.considerExpandingWaypoint = function (done_callback) {
        var self = this;

        if (!done_callback) {
            done_callback = $.noop;
        }

        var emHeight = parseFloat($("body").css("font-size"));
        var threshold_px = emHeight * THRESHOLD_EMS;
        var containerTop = this.elt.offset().top;
        var containerHeight = this.elt.outerHeight();

        /* Find the waypoint nearest to the top of the tree and the top of the
           page. */
        var waypointToExpand;
        $('.waypoint.collapsed', this.elt).each(function (idx, elt) {
            elt = $(elt);
            /* The element's top is measured from the top of the page, but we
               want it relative to the top of the container.  Adjust as
               appropriate. */
            var eltTop = elt.offset().top - containerTop;

            var eltBottom = eltTop + elt.height();


            var waypointVisible = (Math.abs(eltTop) <= (containerHeight + threshold_px)) ||
                                  (Math.abs(eltBottom) <= (containerHeight + threshold_px)) ||
                                  (eltTop < 0 && eltBottom > 0);

            if (waypointVisible) {
                var candidate = {
                    elt: elt,
                    top: eltTop,
                    level: elt.data('level'),
                };

                if (!waypointToExpand) {
                    waypointToExpand = candidate;
                } else {
                    if (waypointToExpand.level > candidate.level || waypointToExpand.top > candidate.top) {
                        waypointToExpand = candidate;
                    }
                }
            }
        });

        if (waypointToExpand) {
            self.expandWaypoint(waypointToExpand.elt, function () {
                self.considerExpandingWaypoint(done_callback);
            });
        } else {
            done_callback();
        }
    };

    var activeExpansions = {};

    LargeTree.prototype.expandWaypoint = function (elt, done_callback) {
        if (elt.hasClass('expanded')) {
            done_callback();
            return;
        }

        var waypoint_button = $('button', $(elt).prev());

        var self = this;
        var uri = elt.data('uri');
        var offset = elt.data('offset');
        var level = elt.data('level');

        var key = uri + "_" + offset;
        if (activeExpansions[key]) {
            return;
        }

        activeExpansions[key] = true;

        this.source.fetchWaypoint(uri, offset).done(function (nodes) {
            var endMarker = self.renderer.endpoint_marker();
            endMarker.data('level', level);

            elt.after(endMarker);

            var newRows = []

            $(nodes).each(function (idx, node) {
                var row = self.renderer.get_node_template();

                row.addClass('largetree-node indent-level-' + level);
                row.data('level', level);

                var title = row.find('.title');
                title.append($('<a class="record-title" />').prop('href', TreeIds.link_url(node.uri)).text(node.title));
                title.attr('title', node.title);

                if (node.child_count == 0) {
                    row.find('.expandme').css('visibility', 'hidden');
                }

                self.renderer.add_node_columns(row, node)

                var tree_id = TreeIds.uri_to_tree_id(node.uri);
                row.data('uri', node.uri);
                row.data('jsonmodel_type', node.jsonmodel_type);
                row.data('position', node.position);
                row.data('parent_id', node.parent_id);
                row.attr('id', tree_id);

                if (self.current_tree_id == tree_id) {
                    row.addClass('current');
                } else {
                    row.removeClass('current');
                }

                newRows.push(row);
            });

            elt.after.apply(elt, newRows);

            elt.removeClass('collapsed').addClass('expanded');

            activeExpansions[key] = false;

            done_callback();
        });
    };

    /*********************************************************************************/
    /* Data source */
    /*********************************************************************************/
    function ASpaceTree(baseURL) {
        this.url = baseURL.replace(/\/+$/, "");
    }


    ASpaceTree.prototype.urlFor = function (action) {
        return this.url + "/" + action;
    }

    ASpaceTree.prototype.fetchRootNode = function () {
        var self = this;

        return $.ajax(this.urlFor("root"),
                      {
                          method: "GET",
                      })
                .done(function (rootNode) {
                    self.cachePrecomputedWaypoints(rootNode);
                });
    };

    ASpaceTree.prototype.fetchNode = function (uri) {
        var self = this;

        return $.ajax(this.urlFor("node"),
                      {
                          method: "GET",
                          data: {
/* THINKME: Should rename node to node_uri?  S */
                              node: uri,
                          }
                      })
                .done(function (node) {
                    self.cachePrecomputedWaypoints(node);
                });

    };

    ASpaceTree.prototype.fetchPathFromRoot = function (node_id) {
        var self = this;

        return $.ajax(this.urlFor("node_from_root"),
                      {
                          method: "GET",
                          data: {
                              node_id: node_id,
                          }
                      });
    };

    ASpaceTree.prototype.fetchWaypoint = function (uri, offset) {
        var cached = this.getPrecomputedWaypoint(uri, offset);

        if (cached) {
            return {
                done: function (callback) {
                    callback(cached);
                }
            };
        } else {
            return $.ajax(this.urlFor("waypoint"),
                          {
                              method: "GET",
                              data: {
                                  node: uri,
                                  offset: offset,
                              }
                          });
        }
    };

    var precomputedWaypoints = {};

    ASpaceTree.prototype.getPrecomputedWaypoint = function (uri, offset) {
        var result;

        if (uri == null) {
            uri = "";
        }

        if (precomputedWaypoints[uri] && precomputedWaypoints[uri][offset]) {
            result = precomputedWaypoints[uri][offset];
            precomputedWaypoints[uri] = {};
        }

        return result;
    };

    ASpaceTree.prototype.cachePrecomputedWaypoints = function (node) {
        $(Object.keys(node.precomputed_waypoints)).each(function (idx, uri) {
            precomputedWaypoints[uri] = node.precomputed_waypoints[uri]
        });
    };

    LargeTree.prototype.setCurrentNode = function(tree_id) {
        $('#'+this.current_tree_id, this.elt).removeClass('current');
        this.current_tree_id = tree_id;

        if ($('#'+this.current_tree_id, this.elt).length == 1) {
            var current = $('#'+this.current_tree_id, this.elt);
            current.addClass('current');
            $.proxy(this.node_selected_callback, self)(current, this);
        } else {
            this.displayNode(this.current_tree_id);
        }
    };



    var renderers = {
        resource: new ResourceRenderer(),
        digital_object: new DigitalObjectRenderer(),
        classification: new ClassificationRenderer(),
    };

    function Tree(datasource_url, tree_container, form_container, toolbar_container, root_uri, read_only, root_record_type) {
        var self = this;

        self.datasource = new ASpaceTree(datasource_url);

        var tree_renderer = renderers[root_record_type];

        self.toolbar_renderer = new TreeToolbarRenderer(tree, toolbar_container);

        self.large_tree = new LargeTree(self.datasource, 
                                        tree_container,
                                        root_uri,
                                        read_only,
                                        tree_renderer, 
                                        function() {
                                            self.ajax_tree =  new AjaxTree(self, form_container);
                                        },
                                        function(node, tree) {
                                            self.toolbar_renderer.render(node);
                                        });
    };


    exports.Tree = Tree;

}(window));
