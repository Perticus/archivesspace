//= require jquery.ba-hashchange
/* FIXME: Scroll top offset needs adjusting I think */

(function (exports) {
    "use strict";

    var WAYPOINT_CLEANUP_MS = 5000;
    var SCROLL_DELAY_MS = 25;
    var THRESHOLD_EMS = 1000;

    function LargeTree(container, datasource, root_uri, read_only) {
        this.elt = container;
        this.source = datasource;
        this.scrollTimer = undefined;

        this.root_uri = root_uri;
        this.root_id = this.uri_to_tree_id(root_uri);
        this.read_only = read_only;

        this.waypoints = {}

        this.initEventHandlers();
        this.renderRoot(function () {
            $(document).triggerHandler('largetree.loaded');
        });
    }

    /* FIXME: generalise */
    LargeTree.prototype.displayNode = function (tree_id) {
        var self = this;
        var ao_id = tree_id.split("_")[2]

        this.source.fetchPathFromRoot(ao_id).done(function (path) {
            self.recursivelyExpandWaypoints(path, function () {
                console.log('a[href="#' +  tree_id +'"]');
                var selected = $('a[href="#tree::' + tree_id +'"]');

                selected.scrollTo(0, {
                    offset: '50%',
                });

                selected.focus();
            });
        });
    }

    LargeTree.prototype.recursivelyExpandWaypoints = function (path, done_callback) {
        var self = this;

        /*
           Here, `path` is a list of objects like:

             node: /some/uri; offset: NN

           which means "expand subtree /some/uri then expand waypoint NN".

           The top-level is special because we automatically show it as expanded, so we skip expanding the root node.
         */

        if (path.length == 0) {
            done_callback();
            return;
        }

        var waypoint_description = path.shift();

        var next_fn = function () {
            var waypoint = self.waypoints[waypoint_description.node][waypoint_description.offset];

            self.expandWaypoint(waypoint, function () {
                self.recursivelyExpandWaypoints(path, done_callback);
            })
        };

        if (waypoint_description.node) {
            var tree_id = self.uri_to_tree_id(waypoint_description.node)

            self.openNode($('#' + tree_id).find('.expandme'), next_fn);
        } else {
            /* this is the root node (subtree already expanded) */
            next_fn();
        }
    };

    LargeTree.prototype.deleteWaypoints = function (parent) {
        var waypoint = parent.next();

        if (!waypoint.hasClass('waypoint')) {
            /* Nothing left to burn */
            return false;
        }

        var waypointLevel = waypoint.data('level');

        if (!waypointLevel) {
            return false;
        }

        /* Delete all elements up to and including the end waypoint marker */
        while (true) {
            var elt = waypoint.next();

            if (elt.length == 0) {
                break;
            }

            if (elt.hasClass('end-marker') && waypointLevel == elt.data('level')) {
                elt.remove();
                break;
            } else {
                elt.remove();
            }
        }

        waypoint.remove();

        return true;
    }

    LargeTree.prototype.openNode = function (button, done_callback) {
        var self = this;
        var parent = button.closest('tr');

        if (button.data('expanded')) {
            /* Collapse it */
            while (self.deleteWaypoints(parent)) {
                /* Remove the elements from one or more waypoints */
            }

            $(button).data('expanded', false);
            $('.expandme-icon', button).removeClass('expanded');
        } else {
            /* Expand it */
            $('.expandme-icon', button).addClass('expanded');
            $(button).data('expanded', true);

            self.source.fetchNode(parent.data('uri')).done(function (node) {
                self.appendWaypoints(parent, parent.data('uri'), node.waypoints, node.waypoint_size, parent.data('level') + 1);
                if (done_callback) {
                    done_callback();
                }
            });
        }
    };

    LargeTree.prototype.initEventHandlers = function () {
        var self = this;

        this.elt.on('scroll', function () {
            if (self.scrollTimer) {
                clearTimeout(self.scrollTimer);
            }

            self.scrollTimer = setTimeout(function () {
                self.considerExpandingWaypoint();
            }, SCROLL_DELAY_MS);
        });

        $(this.elt).on('click', '.expandme', function (e) {
            e.preventDefault();
            self.openNode($(this));
        });
    };

    LargeTree.prototype.makeWaypoint = function (uri, offset, indentLevel) {
        var result = $('<tr class="waypoint collapsed" />');
        result.addClass('indent-level-' + indentLevel);

        result.data('level', indentLevel);
        result.data('uri', uri);
        result.data('offset', offset);

        if (!this.waypoints[uri]) {
            this.waypoints[uri] = {}
        }

        /* Keep a lookup table of waypoints so we can find and expand them programmatically */
        this.waypoints[uri][offset] = result;

        return result;
    };

    LargeTree.prototype.appendWaypoints = function (elt, parentURI, waypointCount, waypointSize, indentLevel) {
        for (var i = waypointCount - 1; i >= 0; i--) {
            var waypoint = this.makeWaypoint(parentURI, i, indentLevel);
            waypoint.css('height', (waypointSize * 2) + 'em');
            elt.after(waypoint);
        }

        var self = this;
        setTimeout(function () {self.considerExpandingWaypoint(); }, 0);
    };

    LargeTree.prototype.renderRoot = function (completed_callback) {
        var self = this;
        var rootList = $('<table class="root" />');

        this.source.fetchRootNode().done(function (rootNode) {
            var row = $('<tr />');
            row.data('uri', rootNode.uri);
            row.attr('id', self.uri_to_tree_id(rootNode.uri));
            row.addClass('root-row');
            row.data('indent', 0);
            row.append(
                $('<td class="title" />')
                   .append($('<a>').attr('href', self.link_url(rootNode.uri))
                                   .text(rootNode.title)));

            row.append($('<td class="level" />').text(rootNode.level));
            row.append($('<td class="type" />').text(rootNode.type));
            row.append($('<td class="container" />').text(rootNode.container));

            rootList.append(row);
            self.appendWaypoints(row, null, rootNode.waypoints, rootNode.waypoint_size, 1);

            self.elt.append(rootList);
            completed_callback();
        });
    };

    LargeTree.prototype.considerExpandingWaypoint = function () {
        var self = this;

        var emHeight = parseFloat($("body").css("font-size"));
        var threshold_px = emHeight * THRESHOLD_EMS;
        var containerHeight = this.elt.outerHeight();

        /* Find the waypoint nearest to the top of the tree and the top of the
           page. */
        var waypointToExpand;
        $('.waypoint.collapsed', this.elt).each(function (idx, elt) {
            elt = $(elt);
            var eltTop = elt.offset().top;
            var eltBottom = eltTop + elt.height();

            var waypointVisible = (Math.abs(eltTop) <= (containerHeight + threshold_px)) ||
                                  (Math.abs(eltBottom) <= (containerHeight + threshold_px)) ||
                                  (eltTop < 0 && eltBottom > 0);

            if (waypointVisible) {
                var candidate = {
                    elt: elt,
                    top: eltTop,
                    level: elt.data('level'),
                };

                if (!waypointToExpand) {
                    waypointToExpand = candidate;
                } else {
                    if (waypointToExpand.level > candidate.level || waypointToExpand.top > candidate.top) {
                        waypointToExpand = candidate;
                    }
                }
            }
        });

        if (waypointToExpand) {
            self.expandWaypoint(waypointToExpand.elt, function () {
                self.considerExpandingWaypoint();
            });
        }
    };

    var activeExpansions = {};

    var row_templates = {
        end_marker: $('<tr class="waypoint end-marker" />'),
        entry: $('<tr> ' +
                 '  <td class="title"><span class="indentor"><button class="expandme"><i class="expandme-icon glyphicon glyphicon-chevron-right" /></button></span> </td>' +
                 '  <td class="level"></td>' +
                 '  <td class="type"></td>' +
                 '  <td class="container"></td>' +
                 '</tr>'),
    };

    LargeTree.prototype.uri_to_tree_id = function(uri) {
      // FIXME: can we move this to the node json/Ruby?
      // e.g. turn /repositories/2/resources/1 into resource_1
      var last_part = uri.replace(/\/repositories\/[0-9]+\//,"");
      var bits = last_part.match(/([a-z_]+)\/([0-9]+)/);
      var type_plural = bits[1].replace(/\//g,'_');
      var id = bits[2];
      var type = type_plural.replace(/s$/, '');
      return [type, id].join('_');
    };

    LargeTree.prototype.link_url = function(uri) {
        // convert the uri into tree-speak
        return "#tree::" + this.uri_to_tree_id(uri);
    };

    LargeTree.prototype.expandWaypoint = function (elt, done_callback) {
        if (elt.hasClass('expanded')) {
            done_callback();
            return;
        }

        var waypoint_button = $('button', $(elt).prev());

        var self = this;
        var uri = elt.data('uri');
        var offset = elt.data('offset');
        var level = elt.data('level');

        var key = uri + "_" + offset;
        if (activeExpansions[key]) {
            return;
        }

        activeExpansions[key] = true;

        this.source.fetchWaypoint(uri, offset).done(function (nodes) {
            var endMarker = row_templates.end_marker.clone(false);
            endMarker.data('level', level);

            elt.after(endMarker);

            var newRows = []

            $(nodes).each(function (idx, node) {
                var row = row_templates.entry.clone(false);

                row.addClass('indent-level-' + level);
                row.data('level', level);

                var title = row.find('.title');
                title.append($('<a />').prop('href', self.link_url(node.uri)).text(node.title));
                title.attr('title', node.title);

                if (node.child_count == 0) {
                    row.find('.expandme').css('visibility', 'hidden');
                }

                row.find('.level').text(node.level);
                row.find('.type').text(node.type);
                row.find('.container').text(node.container);

                row.data('uri', node.uri);
                row.attr('id', self.uri_to_tree_id(node.uri));

                newRows.push(row);
            });

            elt.after.apply(elt, newRows);

            elt.removeClass('collapsed').addClass('expanded');

            activeExpansions[key] = false;

            done_callback();
        });
    };

    /*********************************************************************************/
    /* Data source */
    /*********************************************************************************/
    function ASpaceTree(baseURL) {
        this.url = baseURL.replace(/\/+$/, "");
    }


    ASpaceTree.prototype.urlFor = function (action) {
        return this.url + "/" + action;
    }

    ASpaceTree.prototype.fetchRootNode = function () {
        var self = this;

        return $.ajax(this.urlFor("root"),
                      {
                          method: "GET",
                      })
                .done(function (rootNode) {
                    self.cachePrecomputedWaypoints(rootNode);
                });
    };

    ASpaceTree.prototype.fetchNode = function (uri) {
        var self = this;

        return $.ajax(this.urlFor("node"),
                      {
                          method: "GET",
                          data: {
/* THINKME: Should rename node to node_uri?  S */
                              node: uri,
                          }
                      })
                .done(function (node) {
                    self.cachePrecomputedWaypoints(node);
                });

    };

    ASpaceTree.prototype.fetchPathFromRoot = function (node_id) {
        var self = this;

        return $.ajax(this.urlFor("node_from_root"),
                      {
                          method: "GET",
                          data: {
                              node_id: node_id,
                          }
                      });
    };

    ASpaceTree.prototype.fetchWaypoint = function (uri, offset) {
        var cached = this.getPrecomputedWaypoint(uri, offset);

        if (cached) {
            return {
                done: function (callback) {
                    callback(cached);
                }
            };
        } else {
            return $.ajax(this.urlFor("waypoint"),
                          {
                              method: "GET",
                              data: {
                                  node: uri,
                                  offset: offset,
                              }
                          });
        }
    };

    var precomputedWaypoints = {};

    ASpaceTree.prototype.getPrecomputedWaypoint = function (uri, offset) {
        var result;

        if (uri == null) {
            uri = "";
        }

        if (precomputedWaypoints[uri] && precomputedWaypoints[uri][offset]) {
            result = precomputedWaypoints[uri][offset];
            precomputedWaypoints[uri] = {};
        }

        return result;
    };

    ASpaceTree.prototype.cachePrecomputedWaypoints = function (node) {
        $(Object.keys(node.precomputed_waypoints)).each(function (idx, uri) {
            precomputedWaypoints[uri] = node.precomputed_waypoints[uri]
        });
    };

    exports.LargeTree = LargeTree;
    exports.ASpaceTree = ASpaceTree;

}(window));
