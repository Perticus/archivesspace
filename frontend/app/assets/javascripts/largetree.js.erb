//= require jquery.ba-hashchange

//= require tree_ids_helpers
//= require ajaxtree
//= require tree_renderers
//= require tree_toolbar
//= require tree_resizer

(function (exports) {
    "use strict";

    var SCROLL_DELAY_MS = 25;
    var THRESHOLD_EMS = 300;

    function LargeTree(datasource, container, root_uri, read_only, renderer, tree_loaded_callback, node_selected_callback) {
        this.source = datasource;
        this.elt = container;
        this.scrollTimer = undefined;
        this.renderer = renderer;

        this.root_uri = root_uri;
        this.root_tree_id = TreeIds.uri_to_tree_id(root_uri);
        this.read_only = read_only;

        // default to the root_id
        this.current_tree_id = this.root_tree_id;

        this.waypoints = {};

        this.node_selected_callback = node_selected_callback;
        this.expandHooks = [];

        this.initEventHandlers();
        this.renderRoot(function () {
            tree_loaded_callback();
        });
    }

    LargeTree.prototype.addPlugin = function (plugin) {
        plugin.initialize(this);
    };

    LargeTree.prototype.addExpandHook = function (callback) {
        this.expandHooks.push(callback);
    };

    LargeTree.prototype.displayNode = function (tree_id, done_callback) {
        var self = this;

        var node_id = TreeIds.parse_tree_id(tree_id).id;

        self.source.fetchPathFromRoot(node_id).done(function (path) {
            self.recursivelyExpandWaypoints(path, function () {
                var current = $('#' + tree_id);
                current.find('a.record-title')[0].focus();

                $.proxy(self.node_selected_callback, self)(current, tree);
                done_callback(current);
            });
        });
    };

    LargeTree.prototype.reparentNodes = function (new_parent, nodes, position) {
        var self = this;

        var parent_uri = new_parent.data('uri');

        if (!position) {
            position = 0;
        }

        if (!parent_uri) {
            parent_uri = this.root_uri;
        }

        var uris_to_reopen = [];

        if (!new_parent.hasClass('root-row')) {
            uris_to_reopen.push(new_parent.data('uri'));
        }

        $(nodes).each(function (idx, elt) {
            var level = $(elt).data('level');
            var parent_uri = $(elt).prevAll('.indent-level-' + (level - 1) + ':first').data('uri');

            if (parent_uri) {
                uris_to_reopen.push(parent_uri);
            } else {
                /* parent was root node */
            }
        });

        this.source.reparentNodes(parent_uri,
                                  nodes.map(function (elt) {
                                      return $(elt).data('uri');
                                  }),
                                  position)
            .done(function () {
                self.renderRoot(function () {
                    $($.unique(uris_to_reopen)).each(function (idx, uri) {
                        self.displayNode(TreeIds.uri_to_tree_id(uri),
                                         function (elt) {
                                             self.expandNode(elt);
                                         });
                    });
                });
            });
    };

    LargeTree.prototype.recursivelyExpandWaypoints = function (path, done_callback) {
        var self = this;

        /*
           Here, `path` is a list of objects like:

             node: /some/uri; offset: NN

           which means "expand subtree /some/uri then expand waypoint NN".

           The top-level is special because we automatically show it as expanded, so we skip expanding the root node.
         */

        if (path.length === 0) {
            done_callback();
            return;
        }

        var waypoint_description = path.shift();

        var next_fn = function () {
            var waypoint = self.waypoints[waypoint_description.node][waypoint_description.offset];

            self.expandWaypoint(waypoint, function () {
                self.recursivelyExpandWaypoints(path, done_callback);
            });
        };

        if (waypoint_description.node) {
            var tree_id = TreeIds.uri_to_tree_id(waypoint_description.node);

            self.toggleNode($('#' + tree_id).find('.expandme'), next_fn);
        } else {
            /* this is the root node (subtree already expanded) */
            next_fn();
        }
    };

    LargeTree.prototype.deleteWaypoints = function (parent) {
        var waypoint = parent.next();

        if (!waypoint.hasClass('waypoint')) {
            /* Nothing left to burn */
            return false;
        }

        if (waypoint.hasClass('collapsed')) {
            waypoint.remove();

            return true;
        }

        var waypointLevel = waypoint.data('level');

        if (!waypointLevel) {
            return false;
        }

        /* Delete all elements up to and including the end waypoint marker */
        while (true) {
            var elt = waypoint.next();

            if (elt.length === 0) {
                break;
            }

            if (elt.hasClass('end-marker') && waypointLevel == elt.data('level')) {
                elt.remove();
                break;
            } else {
                elt.remove();
            }
        }

        waypoint.remove();

        return true;
    };

    LargeTree.prototype.toggleNode = function (button, done_callback) {
        var self = this;
        var parent = button.closest('tr');

        if (button.data('expanded')) {
            self.collapseNode(parent, done_callback);
        } else {
            self.expandNode(parent, done_callback);
        }
    };

    LargeTree.prototype.expandNode = function (row, done_callback) {
        var self = this;
        var button = row.find('.expandme');

        $('.expandme-icon', button).addClass('expanded');
        $(button).data('expanded', true);

        self.source.fetchNode(row.data('uri')).done(function (node) {
            self.appendWaypoints(row, row.data('uri'), node.waypoints, node.waypoint_size, row.data('level') + 1);

            if (done_callback) {
                done_callback();
            }
        });
    };

    LargeTree.prototype.collapseNode = function (row, done_callback) {
        var self = this;

        while (self.deleteWaypoints(row)) {
            /* Remove the elements from one or more waypoints */
        }

        var button = row.find('.expandme');

        $(button).data('expanded', false);
        $('.expandme-icon', button).removeClass('expanded');

        if (done_callback) {
            done_callback();
        }
    };

    LargeTree.prototype.initEventHandlers = function () {
        var self = this;
        var currentlyExpanding = false;

        /* Content loading */
        this.elt.on('scroll', function (event) {
            if (self.scrollTimer) {
                clearTimeout(self.scrollTimer);
            }

            self.scrollTimer = setTimeout(function () {
                if (!currentlyExpanding) {
                    currentlyExpanding = true;

                    self.considerExpandingWaypoint(function () {
                        currentlyExpanding = false;
                    });
                }
            }, SCROLL_DELAY_MS);
        });

        /* Expand/collapse nodes */
        $(this.elt).on('click', '.expandme', function (e) {
            e.preventDefault();
            self.toggleNode($(this));
        });
    };

    LargeTree.prototype.makeWaypoint = function (uri, offset, indentLevel) {
        var result = $('<tr class="waypoint collapsed" />');
        result.addClass('indent-level-' + indentLevel);

        result.data('level', indentLevel);
        result.data('uri', uri);
        result.data('offset', offset);

        if (!this.waypoints[uri]) {
            this.waypoints[uri] = {};
        }

        /* Keep a lookup table of waypoints so we can find and expand them programmatically */
        this.waypoints[uri][offset] = result;

        return result;
    };

    LargeTree.prototype.appendWaypoints = function (elt, parentURI, waypointCount, waypointSize, indentLevel) {
        for (var i = waypointCount - 1; i >= 0; i--) {
            var waypoint = this.makeWaypoint(parentURI, i, indentLevel);

            /* We force the line height to a constant 2em so we can predictably
               guess how tall to make waypoints.  See largetree.less for where we
               set this on table.td elements. */
            waypoint.css('height', (waypointSize * 2) + 'em');
            elt.after(waypoint);
        }

        var self = this;
        setTimeout(function () {self.considerExpandingWaypoint(); }, 0);
    };

    LargeTree.prototype.renderRoot = function (done_callback) {
        var self = this;
        var rootList = $('<table class="root" />');

        this.source.fetchRootNode().done(function (rootNode) {
            var row = self.renderer.get_root_template();

            row.data('uri', rootNode.uri);
            row.attr('id', TreeIds.uri_to_tree_id(rootNode.uri));
            row.addClass('root-row');
            row.data('indent', 0);
            row.data('jsonmodel_type', rootNode.jsonmodel_type);
            row.find('.title').append($('<a>').attr('href', TreeIds.link_url(rootNode.uri))
                                              .text(rootNode.title));

            rootList.append(row);
            self.appendWaypoints(row, null, rootNode.waypoints, rootNode.waypoint_size, 1);

            /* Remove any existing table */
            self.elt.find('table.root').remove();
            self.elt.prepend(rootList);
            self.renderer.add_root_columns(row, rootNode);
            if (done_callback) {
                done_callback();
            }
        });
    };

    LargeTree.prototype.considerExpandingWaypoint = function (done_callback) {
        var self = this;

        if (!done_callback) {
            done_callback = $.noop;
        }

        var emHeight = parseFloat($("body").css("font-size"));
        var threshold_px = emHeight * THRESHOLD_EMS;
        var containerTop = this.elt.offset().top;
        var containerHeight = this.elt.outerHeight();

        /* Find the waypoint nearest to the top of the tree and the top of the
           page. */
        var waypointToExpand;
        $('.waypoint.collapsed', this.elt).each(function (idx, elt) {
            elt = $(elt);
            /* The element's top is measured from the top of the page, but we
               want it relative to the top of the container.  Adjust as
               appropriate. */
            var eltTop = elt.offset().top - containerTop;

            var eltBottom = eltTop + elt.height();


            var waypointVisible = (Math.abs(eltTop) <= (containerHeight + threshold_px)) ||
                                  (Math.abs(eltBottom) <= (containerHeight + threshold_px)) ||
                                  (eltTop < 0 && eltBottom > 0);

            if (waypointVisible) {
                var candidate = {
                    elt: elt,
                    top: eltTop,
                    level: elt.data('level'),
                };

                if (!waypointToExpand) {
                    waypointToExpand = candidate;
                } else {
                    if (waypointToExpand.level > candidate.level || waypointToExpand.top > candidate.top) {
                        waypointToExpand = candidate;
                    }
                }
            }
        });

        if (waypointToExpand) {
            self.expandWaypoint(waypointToExpand.elt, function () {
                self.considerExpandingWaypoint(done_callback);
            });
        } else {
            done_callback();
        }
    };

    var activeExpansions = {};

    LargeTree.prototype.expandWaypoint = function (elt, done_callback) {
        if (elt.hasClass('expanded')) {
            done_callback();
            return;
        }

        var self = this;
        var uri = elt.data('uri');
        var offset = elt.data('offset');
        var level = elt.data('level');

        var key = uri + "_" + offset;
        if (activeExpansions[key]) {
            return;
        }

        activeExpansions[key] = true;

        this.source.fetchWaypoint(uri, offset).done(function (nodes) {
            var endMarker = self.renderer.endpoint_marker();
            endMarker.data('level', level);

            elt.after(endMarker);

            var newRows = [];

            $(nodes).each(function (idx, node) {
                var row = self.renderer.get_node_template();

                row.addClass('largetree-node indent-level-' + level);
                row.data('level', level);

                var title = row.find('.title');
                title.append($('<a class="record-title" />').prop('href', TreeIds.link_url(node.uri)).text(node.title));
                title.attr('title', node.title);

                if (node.child_count === 0) {
                    row.find('.expandme').css('visibility', 'hidden');
                }

                self.renderer.add_node_columns(row, node);

                var tree_id = TreeIds.uri_to_tree_id(node.uri);
                row.data('uri', node.uri);
                row.data('jsonmodel_type', node.jsonmodel_type);
                row.data('position', node.position);
                row.data('parent_id', node.parent_id);
                row.attr('id', tree_id);

                if (self.current_tree_id == tree_id) {
                    row.addClass('current');
                } else {
                    row.removeClass('current');
                }

                newRows.push(row);
            });

            elt.after.apply(elt, newRows);

            elt.removeClass('collapsed').addClass('expanded');

            activeExpansions[key] = false;

            $(self.expandHooks).each(function (idx, hook) {
                hook();
            });

            done_callback();
        });
    };

    /*********************************************************************************/
    /* Data source */
    /*********************************************************************************/
    function ASpaceTree(baseURL) {
        this.url = baseURL.replace(/\/+$/, "");
    }


    ASpaceTree.prototype.urlFor = function (action) {
        return this.url + "/" + action;
    };

    ASpaceTree.prototype.fetchRootNode = function () {
        var self = this;

        return $.ajax(this.urlFor("root"),
                      {
                          method: "GET",
                      })
                .done(function (rootNode) {
                    self.cachePrecomputedWaypoints(rootNode);
                });
    };

    ASpaceTree.prototype.fetchNode = function (uri) {
        var self = this;

        return $.ajax(this.urlFor("node"),
                      {
                          method: "GET",
                          data: {
                              /* THINKME: Should rename node to node_uri?  S */
                              node: uri,
                          }
                      })
                .done(function (node) {
                    self.cachePrecomputedWaypoints(node);
                });

    };

    ASpaceTree.prototype.fetchPathFromRoot = function (node_id) {
        var self = this;

        return $.ajax(this.urlFor("node_from_root"),
                      {
                          method: "GET",
                          data: {
                              node_id: node_id,
                          }
                      });
    };

    ASpaceTree.prototype.fetchWaypoint = function (uri, offset) {
        var cached = this.getPrecomputedWaypoint(uri, offset);

        if (cached) {
            return {
                done: function (callback) {
                    callback(cached);
                }
            };
        } else {
            return $.ajax(this.urlFor("waypoint"),
                          {
                              method: "GET",
                              data: {
                                  node: uri,
                                  offset: offset,
                              }
                          });
        }
    };

    ASpaceTree.prototype.reparentNodes = function (new_parent_uri, node_uris, position) {
        var target = TreeIds.backend_uri_to_frontend_uri(new_parent_uri);

        return $.ajax(target + "/accept_children",
               {
                   method: 'POST',
                   data: {
                       children: node_uris,
                       index: position,
                   }
               });
    };

    var precomputedWaypoints = {};

    ASpaceTree.prototype.getPrecomputedWaypoint = function (uri, offset) {
        var result;

        if (uri === null) {
            uri = "";
        }

        if (precomputedWaypoints[uri] && precomputedWaypoints[uri][offset]) {
            result = precomputedWaypoints[uri][offset];
            precomputedWaypoints[uri] = {};
        }

        return result;
    };

    ASpaceTree.prototype.cachePrecomputedWaypoints = function (node) {
        $(Object.keys(node.precomputed_waypoints)).each(function (idx, uri) {
            precomputedWaypoints[uri] = node.precomputed_waypoints[uri];
        });
    };

    LargeTree.prototype.setCurrentNode = function(tree_id) {
        $('#'+this.current_tree_id, this.elt).removeClass('current');
        this.current_tree_id = tree_id;

        if ($('#'+this.current_tree_id, this.elt).length == 1) {
            var current = $('#'+this.current_tree_id, this.elt);
            current.addClass('current');
            $.proxy(this.node_selected_callback, self)(current, this);
        } else {
            this.displayNode(this.current_tree_id);
        }
    };



    var renderers = {
        resource: new ResourceRenderer(),
        digital_object: new DigitalObjectRenderer(),
        classification: new ClassificationRenderer(),
    };

    function Tree(datasource_url, tree_container, form_container, toolbar_container, root_uri, read_only, root_record_type) {
        var self = this;

        self.datasource = new ASpaceTree(datasource_url);

        var tree_renderer = renderers[root_record_type];

        self.toolbar_renderer = new TreeToolbarRenderer(tree, toolbar_container);

        self.large_tree = new LargeTree(self.datasource, 
                                        tree_container,
                                        root_uri,
                                        read_only,
                                        tree_renderer, 
                                        function() {
                                            self.ajax_tree = new AjaxTree(self, form_container);
                                            self.resizer = new TreeResizer(self, tree_container);
                                        },
                                        function(node, tree) {
                                            self.toolbar_renderer.render(node);
                                        });


        self.large_tree.addPlugin(new LargeTreeDragDrop());
    }


    exports.Tree = Tree;

}(window));
